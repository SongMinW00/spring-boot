package com.example.demo.controller;

import com.example.demo.Service.UserService;
import com.example.demo.constant.ServiceURIManagement;
import com.example.demo.domain.dto.request.SignUpRequestDTO;
import com.example.demo.domain.entity.user.Member;
import com.example.demo.security.validate.CheckEmailValidator;
import com.example.demo.security.validate.CheckUsernameValidator;
import lombok.AllArgsConstructor;

import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.annotation.CurrentSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

@Controller // 이 클래스는 컨트롤러 기능을 수행한다고 정의
@RequiredArgsConstructor
// Bean 주입 방식과 관련이 있으며, 생성자로 Bean 객체를 받는 방식을 해결해주는 어노테이션입니다. 그래서 UserService 객체를 주입 받을 때 @Autowired 같은 특별한 어노테이션을 부여하지 않았습니다

//@Transactional //DB와 관련된, 트랜잭션이 필요한 서비스 클래스 혹은 메서드에 @Transactional 어노테이션을 달아주면된다.
//@RequestMapping(path="content") // THis means URL's start with /content
public class UserController {

    private final UserService userService;
    private final CheckUsernameValidator checkUsernameValidator;
    private final CheckEmailValidator checkEmailValidator;

    /* 커스텀 유효성 검증을 위해 추가 */
    @InitBinder
    public void validatorBinder(WebDataBinder binder){
        binder.addValidators(checkUsernameValidator);
        binder.addValidators(checkEmailValidator);
    }
// final은 오직 한번만 할당 할 수 있는 entity를 정의할때 사용된다.

     // This means to get the bean called userRepository
            // Which is auto-generated by Spring, we will use it to handle the data

    @GetMapping(ServiceURIManagement.NOW_VERSION + "/user/my-page")
    public String myPage() throws Exception{
        return "/content/user/my-page";
    }


    @RequestMapping(value = "/", method = RequestMethod.GET)
    public String home(){

        return "content/index";
    }

    @RequestMapping(value="/register", method = RequestMethod.GET)
    public String register(){
        return "content/register";
    }
    @PostMapping(value="/register")

    public String joinUser(@Valid SignUpRequestDTO signUpRequestDTO, Errors errors, Model model, HttpServletResponse response) throws IOException {
        if(errors.hasErrors()){
            /* 회원가입 실패시 입력 데이터 값을 유지 */
            model.addAttribute("signUpRequestDTO", signUpRequestDTO);
            /* 유효성 통과 못한 필드와 메시지 핸들링 */

            Map<String, String> validatorResult = userService.validateHandling(errors);
            for(String key : validatorResult.keySet()){
                model.addAttribute(key, validatorResult.get(key));
            }

            return "content/register";
        }
//        userService.checkUsernameDuplication(signUpRequestDTO, response);
//        userService.checkEmailDuplication(signUpRequestDTO, response);
        userService.joinUser(signUpRequestDTO);
        response.setContentType("text/html; charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<script>alert('계정이 등록 되었습니다. 다시 로그인 해주세요.');</script>");
        out.flush();
        return "content/login";
    }

//    @RequestMapping(value="/login", method = RequestMethod.POST)
//    public String logindo(SignUpRequestDTO signUpRequestDTO, Model model){
//
//        return "content/welcome";
//    }
    @RequestMapping(value = "/login", method = RequestMethod.GET)
    public String login(@RequestParam(value = "error", required = false) String error,
                        @RequestParam(value = "exception", required = false) String exception,
                        Model model){
        userService.login(error, exception, model);

        return "content/login";
    }

    @GetMapping("/logout")
    public String logout(HttpServletRequest request, HttpServletResponse response) {
        userService.logout(request, response);

        return "redirect:/";
    }

    @GetMapping("/denied")
    public String accessDenied(
            @RequestParam(value = "exception", required = false) String exception,
            Model model) {

        userService.accessDenied(exception, model);

        return "content/error/denied";
    }
    @RequestMapping(value = "/welcome", method = RequestMethod.GET)
    public String welcome(String username, Model model){

        System.out.println("username: " + username);
        return "content/welcome";
    }
//    @GetMapping(value = "/logout")
//    public String logoutPage(HttpServletRequest request, HttpServletResponse response) {
//        new SecurityContextLogoutHandler().logout(request, response, SecurityContextHolder.getContext().getAuthentication());
//        return "redirect:/login";
//    }

//    @GetMapping("/list")
//    public String list(Model model){
//
//        List<UserVo> users = userService.findMenbers();
//        model.addAttribute("users", users);
//        return "content/list";
//    }


}
